"""
Name: Madeline Boss
Date: 9/4/25
Assignment: 1
Due Date: 9/12/25
About this project: the goal of this assignment is to create a game that has different strategies and to be able to compare each of them and find which performs the best.
Assumptions: Assume user inputs the correct number of strategies (max 10)
All work below was performed solely by Madeline Boss.
I [did not use ] code generated by an AI tool.
"""

import random
import sys

#base definitions
defect = 0
cooperate = 1


#range reward function
#this functions calculates the reward used in probe and lock
def rangeReward(beg, end, myHistory, oppHistory):
    myTotal = 0
    oppTotal = 0
    for i in range(beg, end):
        # if i cooperate and my opp cooperates, we both get 3 points
        if myHistory[i] == 1 and oppHistory[i] == 1:
            myTotal += 3
            oppTotal +=3
        #if i defect and my opp cooperates, i get 5 points
        elif myHistory[i] == 0 and oppHistory[i] == 1:
            myTotal += 5
        #if i defect and my opp defects we both get 1 point
        elif myHistory[i] == 0 and oppHistory[i] == 0:
            myTotal += 1
            oppTotal += 1
    #returning how many points i have earned
    return myTotal

#cooperate reward function for continuous probe
def myMove(myHistory, oppHistory):
    myLen = len(myHistory)
    oppLen = len(oppHistory)
    defectCount = 0
    defectPoints = 0
    coopCount = 0
    coopPoints = 0

    #checking that me and my opponent have taken an equal amount of turns
    if myLen == oppLen:
        for i in range(0, myLen):
            #if i defect then defect count +1
            if myHistory[i] == 0:
                defectCount += 1
                #if my opp defects, then i only get one point added to my history, defect point count +1
                if oppHistory[i] == 0:
                    defectPoints += 1
                #if my opp cooperates, then i get five points added to my history, defect point count +5
                elif oppHistory[i] == 1:
                    defectPoints += 5
            #if i cooperate then cooperate count +1
            elif myHistory[i] == 1:
                coopCount += 1
                #if my opp cooperates, then i get 3 points added to my history, cooperate point count +3
                if oppHistory[i] == 1:
                    coopPoints += 3
    #guard to prevent diviision by zerp
    if defectCount == 0:
        avg_defe = 0
    else: 
        #calculating the average amount of points gained when i chose to defect
        avg_defe = defectPoints / defectCount
    
    #guard to prevent division by zero
    if coopCount ==0:
        avg_coop = 0
    else:
        #calculating the average amount of points i gained when i chose to cooperate
        avg_coop = coopPoints / coopCount

    #if i got more points for defecting, then i choose to defect
    if avg_defe >= avg_coop:
        return defect
    #if i got more points for cooperating, then i choose to cooperate
    elif avg_coop > avg_defe:
        return cooperate
    

#calculating the probability that my opponent will choose cooperate or defect, then choosing from there which choice will give me
#the most points
def oppProbability(myHistory, oppHistory):
    defectCount = 0
    cooperateCount = 0
    oppLen = len(oppHistory)
    for i in range(oppLen):
        if oppHistory[i] == 0:
            defectCount += 1
        else:
            cooperateCount +=1
    
        #finding the probability that my opp chooses defect or cooperate
        defectProb = defectCount / oppLen
        cooperateProb = cooperateCount / oppLen

        #finding expected point outcome of choosing defect or cooperate
        expected_points_coop = 3 * cooperateProb + 0 * defectProb
        expected_points_defect = 5 * cooperateProb + 1 * defectProb

        #whichever choice has the higher expected point outcome, i choose
        if expected_points_defect >= expected_points_coop:
            return defect
        else:
            return cooperate
   


#strategies
#strat 1
def strategy_alwaysCooperate(myHistory, oppHistory):
    return cooperate

#strat 2
def strategy_alwaysDefect(myHistory, oppHistory):
    return defect

#strat 3
def strategy_probeAndLock(myHistory, oppHistory):
    if(len(myHistory) < 20):
        return defect
    elif(len(myHistory) < 40):
        return cooperate
    else:
        reward1 = rangeReward(0, 20, myHistory, oppHistory)
        reward2 = rangeReward(20, 40, myHistory, oppHistory)
        if(reward1 > reward2):
            return defect
        else:
            return cooperate
        
#strat 4
def strategy_continuousProbe(myHistory, oppHistory):
    myLen = len(myHistory)

    #first round i will defect
    if myLen == 0:
        return defect
    #second round i will cooperate
    elif myLen == 1:
        return cooperate
    #for the rest of the rounds, i will assess our histories and choose from there
    elif myLen > 1:
        return myMove(myHistory, oppHistory)

    

#strat 5
def strategy_defectUntilCooperate(myHistory, oppHistory):
    #this flag determines if my opponent has cooperated, start at false
    flag = False
    #in the range of my opp's entire play history, find if they cooperate
    for i in range (len(oppHistory)):
        if oppHistory[i] == 1:
            flag = True
    #if they cooperate, then i will always cooperate
    if flag == True:
        return cooperate
    #if they have not yet cooperated, then i will defect
    else:
        return defect    

#strat 6
def strategy_opponentCooperate10Percentage(myHistory, oppHistory):
    coop = 0
    #finding the number of times my opponent has cooperated
    for i in range(0, len(oppHistory)):
        if oppHistory[i] == 1:
            coop += 1
    
    total = len(oppHistory)
    #preventing division by 0
    if total == 0:
        return defect
    #finding the percentage that my opp cooperates
    else:
        percent = int((coop / total) * 100)
        #if they cooperate more than 10% of the time, then i will also cooperate
        if percent > 10:
            return cooperate
        #if not, i will defect
        else:
            return defect

#strat 7
def strategy_opponentCooperate50Percentage(myHistory, oppHistory):
    #same logic as previos function, except with 50%
    coop = 0
    for i in range(0, len(oppHistory)):
        if oppHistory[i] == 1:
            coop += 1
    
    total = len(oppHistory)
    if total == 0:
        return defect
    else:
        percent = int((coop / total) * 100)
        if percent > 50:
            return cooperate
        else:
            return defect

#strat 8
def strategy_opponentCooperate90Percentage(myHistory, oppHistory):
    #same logic as strategy six, except i base my decision of 90%
    coop = 0
    for i in range(0, len(oppHistory)):
        if oppHistory[i] == 1:
            coop += 1
        
    total = len(oppHistory)
    if total == 0:
        return defect
    else:
        percent = int((coop / total) * 100)
        if percent > 90:
            return cooperate
        else:
            return defect
    

#strat 9
def strategy_random50(myHistory, oppHistory):
    #generating a random integer
    random_int = random.randint(1, 10)
    #if this random integer is divisible by 2, then i defect
    if random_int % 2 == 0:
        return defect
    #else i cooperate
    else:
        return cooperate

#strat 10
def strategy_MadelineABoss(myHistory, oppHistory):
    myLen = len(myHistory)
    oppLen = len(oppHistory)

    if myLen == oppLen:
        if myLen ==0:
            return defect
        elif myLen == 1:
            return cooperate
        else:
            return oppProbability(myHistory, oppHistory)

#calculating rewards
def rewardCalc(me, opp):
    # if we both cooperate, we each get 3 points
    if me == 1 and opp == 1:
        return 3, 3
    #if i cooperate and my opp defects, they get 5 points
    elif me == 1 and opp == 0:
        return 0, 5
    #if i defect and my opp cooperates, i get 5 points
    elif me == 0 and opp == 1:
        return 5, 0
    #the only other case is both defect, then we both get 1 point
    else:
        return 1, 1

def gameSim(num_of_iterations, num_of_strategies):
    myHistory, oppHistory = [], []
    #dictionary of strategies attached to their IDs
    strategies = {
        0:("always cooperate", strategy_alwaysCooperate), 
        1:("always defect", strategy_alwaysDefect),
        2:("probe and lock", strategy_probeAndLock),
        3:("continuous probe", strategy_continuousProbe),
        4:("defect until coopaerate", strategy_defectUntilCooperate),
        5:("opponent cooperate 10%", strategy_opponentCooperate10Percentage),
        6:("opponent cooperate 50%", strategy_opponentCooperate50Percentage),
        7:("opponent cooperate 90%", strategy_opponentCooperate90Percentage),
        8:("random 50", strategy_random50),
        9:("madelineABoss", strategy_MadelineABoss)
    }

    #builds a new dictionary aligning each strategu with its score
    scores = {strategies[i][0]: 0 for i in range(num_of_strategies)}

    #for loop for strategy 1
    for i in range(num_of_strategies):
        #for loop for strategy 2
        for j in range(i + 1, num_of_strategies):
            #assigning strategies to players and variable to be able to call on of the strategy functions
            p1, strat1 = strategies[i]
            p2, strat2 = strategies[j]

            #making sure that the history is fresh for each match up
            myHistory, oppHistory = [], []
          
            #running the number of rounds input by the user
            for m in range(num_of_iterations):
                move1 = strat1(myHistory, oppHistory)
                move2 = strat2(oppHistory, myHistory)
                #calculating the reward each player got
                me, opp = rewardCalc(move1, move2)
                #updating the dicitonary
                scores[p1] += me
                scores[p2] += opp
                #updating the history
                myHistory.append(move1)
                oppHistory.append(move2)

    #printing the totals after the game ends
    for name, total in scores.items():
        print(f"{name}: {total}")


            
#running the program
def main():
    #default inputs
    num_of_iterations = 2000
    num_of_strategies = 8

    #allowing user input in command line, in the same command as running the program
    if len(sys.argv) >=2:
        num_of_iterations = int(sys.argv[1])
    if len(sys.argv) >= 3:
        num_of_strategies = int(sys.argv[2])

    #calling the game simulation with the inputs from the user passed in
    gameSim(num_of_iterations, num_of_strategies)


if __name__ == "__main__":
    main()
    

