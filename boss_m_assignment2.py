"""
Name: Madeline Boss
Date: September 20, 2025
Assignment: 2
Due Date: September 26, 2025
About this project: This program analyzes Apache web server access logs and reports
the most active hosts and most frequently downloaded resources in a given date range.
Assumptions: Input log file is in the Combined Log Format (CLF part only).
All work below was performed solely by Madeline Boss.
I did not use code generated by an AI tool.
"""

import sys
from datetime import datetime, timezone, timedelta
from collections import defaultdict

def parse_date(date_str):
    """
    Convert log date string [09/Sep/2025:12:34:56 +0000] into datetime object.
    """
    return datetime.strptime(date_str, "[%d/%b/%Y:%H:%M:%S %z]")

def parse_line(line):
    """
    Parse a single CLF line into its fields.
    Expected format:
    host ident authuser [date] "request" status bytes
    """
    try:
        parts = line.split()
        host = parts[0]
        date_str = parts[3] + " " + parts[4]  # [date:time zone]
        request = " ".join(parts[5:8]).strip('"')
        status = parts[8]
        size = parts[9] if parts[9] != "-" else 0
        return host, date_str, request, status, size
    except Exception as e:
        print(f"Skipping line (parse error): {line.strip()} -> {e}")
        return None

def within_range(date_obj, start_date, end_date):
    """
    Check if a datetime object falls within the start and end date (inclusive).
    """
    return start_date <= date_obj <= end_date

def main():
    if len(sys.argv) < 2:
        print("Usage: python3 boss_m_assignment2.py <logFilePath> [start_date] [end_date]")
        return

    logFilePath = sys.argv[1]

    # Default date range
    start_date_str = "01/01/0001"
    end_date_str = "12/30/9999"

    if len(sys.argv) > 2:
        start_date_str = sys.argv[2]
    if len(sys.argv) > 3:
        end_date_str = sys.argv[3]

    input_date_format = "%m/%d/%Y"
    start_date = datetime.strptime(start_date_str, input_date_format).replace(tzinfo=timezone.utc)
    end_date = datetime.strptime(end_date_str, input_date_format).replace(tzinfo=timezone.utc) + timedelta(days=1) - timedelta(seconds=1)

    print(f"Analyze {logFilePath} between {start_date} and {end_date_str}")

    # Counters
    host_counts = defaultdict(int)
    resource_counts = defaultdict(int)
    host_first_seen = {}
    resource_first_seen = {}
    total_lines = 0
    in_range_lines = 0

    # Process log file
    with open(logFilePath, "r") as f:
        for line_num, line in enumerate(f, start=1):
            total_lines += 1
            parsed = parse_line(line)
            if not parsed:
                continue
            host, date_str, request, status, size = parsed

            try:
                log_date = parse_date(date_str)
            except Exception as e:
                print(f"Skipping line {line_num}: could not parse date {date_str} ({e})")
                continue

            if within_range(log_date, start_date, end_date):
                in_range_lines += 1

                # Count host accesses
                host_counts[host] += 1
                if host not in host_first_seen:
                    host_first_seen[host] = line_num

                # Count resource downloads (GET only)
                if request.startswith("GET"):
                    parts = request.split()
                    if len(parts) > 1:
                        resource = parts[1]
                        resource_counts[resource] += 1
                        if resource not in resource_first_seen:
                            resource_first_seen[resource] = line_num

    print(f"{in_range_lines}/{total_lines} lines from {start_date_str} to {end_date_str}")

    # Sort results: descending count, then first seen to break ties
    top_hosts = sorted(host_counts.items(), key=lambda x: (-x[1], host_first_seen[x[0]]))
    top_resources = sorted(resource_counts.items(), key=lambda x: (-x[1], resource_first_seen[x[0]]))

    def print_top(data, label, max_rank=30):
        """
        Print the top hosts or resources, handling ties at the last rank.
        """
        if not data:
            print(f"\nTop 0 {label}:")
            return

        print(f"\nTop {min(max_rank, len(data))} {label}:")

        rank = 0
        last_count = None
        printed = 0

        for i, (item, count) in enumerate(data, start=1):
            if count != last_count:
                rank = printed + 1
            if rank > max_rank and count != last_count:
                break
            print(f"  No. {i}: {item} {count}")
            last_count = count
            printed += 1

    # Output results
    print_top(top_hosts, "most active hosts", 30)
    print_top(top_resources, "most downloaded resources", 30)

if __name__ == "__main__":
    main()
