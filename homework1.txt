COP4521 Homework 1

Name: Madeline Boss            FSU login: mab22bb

1 (10 points). The content of file aa.py is as follows:
--
print("aa.py Top level", __name__)
def hello():
    print("Hello from", __name__)
--

The content of file bb.py is as follows:
--
import aa

print("bb.py Top level", __name__)
aa.hello()
--

What is the output when we run bb with 'python3 bb.py' on linprog? (5 points)
Explain why each line is printed as it is (5 points)

Output of bb.py:
aa.py Top level aa
bb.py Top level __main__
Hello from aa

Explanation:
When bb.py is run, the first line of code is import aa. This line executes aa.py. Since aa.py is not being directly run, __name__ is shown as the name of the file, aa.
If aa.py were being directly run, __name__ would be shown as __main__. The next and final part of aa.py is a function definition that has not been called yet. aa.py only
prints once when it's imported, and the function body doesn't executed until it is called later on.
Once aa.py is executed, the program will now go through what is left in bb.py. The line after the import prints __name__ as __main__ since bb.py is being run directly. 
Then, the function from aa.py is called, and once again since aa.py is imported, the __name__ is aa. The main point here 
is that the script being run dirfectly will always have __name__ = "__main__" and imported modules always have __name__ = "module_name"



2 (10 points). Consider the following code segment:

def addObj(a, b):
    a.append(b)
    print('Inside 1: a = ', a)
    a = a + [b]
    print('Inside 2: a = ', a)

lst = [1, 2, 3]
addObj(lst, 100)
print('Outside: lst = ', lst)

What is the output when the code segment is executed? (5 points)
Explain why each line is printed as it is (5 points)

Output:
Inside 1: a = [1, 2, 3, 100]
Inside 2: a = [1, 2, 3, 100, 100]
Outside: lst = [1, 2, 3, 100]

Explanation:
The first line is printed with the original list, plus a 100, because the list was appended and the 100 was added to the list. When 
appending an object, it changes the original object. When using concatenation, which is used to print line 2, it creates a whole new object.
Line 2 prints with 2 "100"s because after appending the list, the list now includes 100, then using concatenation a new list is created with
the additional 100. Line 3 does not have 2 "100"s because the concatenation's affect was only inside the function. It does not change the list
outside of the function. Appending in the first line changed the original list, while the concatenation created a new one with the change which
was then discarded once the function was over. 



3. (10 points) Let a function prototype be

def foo(arg1, arg2, arg3, arg4 = 1, arg5 = "one"):

Which of the following function calls are valid in python:

foo('aaa', 'bbb', 'ccc')
foo(arg2 = 'bbb', arg1 = 'aaa', 'bbb')
foo('aaa', 'ccc', arg5='ddd', arg2='bbb')
foo('aaa', arg3 = 'bbb', arg2 = 'ccc', arg5='ddd')
foo(arg5 = 'eee', arg4 = 2,  arg3 = 'ccc', arg2 = 'bbb', arg1 = 'bbb')

Answer: 
foo('aaa', 'bbb', 'ccc')
foo('aaa', arg3 = 'bbb', arg2 = 'ccc', arg5='ddd')
foo(arg5 = 'eee', arg4 = 2,  arg3 = 'ccc', arg2 = 'bbb', arg1 = 'bbb')




4. (10 points) Write a function that can take any number of positional arguments followed by
any number of keyword arguments. The function then prints the last positional argment and the
last keyword arguments.

def anyNum(*argm, **argg):
    posLen = len(argm)
    goalPos = posLen - 1
    print(argm[goalPos])

    goalKey = list(argg.keys())[len(argg) - 1]
    print(argg[goalKey])

anyNum(1, 2, 3, a = 10, b = 20, c = 30)

Output:
3
30


5 (20 points). Let the content of foo.py be the following:

------------
count = 0

def printUpdateCount():
    print(count)
    for i in range (0, 4):
        count = 4

print(count)
printUpdateCount()
-------------

What is the output when you run the code with 'python3 foo.py' on linprog (10 points)?
Explain your answer (10 points)

Output:
boss@linprog6.cs.fsu.edu:~>python3 count.py 
0
Traceback (most recent call last):
  File "/home/majors/boss/count.py", line 9, in <module>
    printUpdateCount()
    ~~~~~~~~~~~~~~~~^^
  File "/home/majors/boss/count.py", line 4, in printUpdateCount
    print(count)
          ^^^^^
UnboundLocalError: cannot access local variable 'count' where it is not associated with a value

Explanation:
In this piece of code, the count variable was declared outside of the function definition so it has been initialized globally.
It is not passed into the function, so though it has been declared in the program, the function does not have access to it.
When it tries to execute print(count) in the function, it cannot because there is no local variable called count in the function.
If count was either declared in the function, or it was passed into the function, the code would work without any errors, but due to
the LEGB rule, the function does not know what count is, and there is nothing associated with it. 




6 (20 points). What is the output of the following code segment when executed
(10 points)? Briefly explain (10 points).

def aaa(x):
    def bbb(y):
        c = x * x
	return c * y

    return bbb

area10 = aaa(10)

print(area10(3))
print(area10(5))

Output:
When the code runs with the current indentation, an error is thrown due to inconsistent use of tabs. This error is thrown at line 4.
With correct indentation, the code would look like this:
def aaa(x):
    def bbb(y):
        c = x * x
        return c * y

    return bbb

area10 = aaa(10)

print(area10(3))
print(area10(5))

And the output would be
300
500

Explanation:
Return statements should always be included in the function definition. When there is correct indentation this is an example of nested
function definitions. When print(area10(3)) is called, 10 is passed into aaa(x) giving aaa(10), then because aaa(10)




7 (20 points). Let a sequence of numbers be 5, 5, 3, 7, 1, 9, ...
More precisely, the first three numbers are x_1= 5, x_2=5, and x_3 = 3.
Following that x_i = x_{i-3} + x_{i-2} - x_{i-1}. For example,
x_4 = x_1 + x_2 - x_3 = 5 + 5 - 3 = 7; x_5 = x_2 + x_3 - x_4 = 5 + 3 - 7 = 1;
and so on. Write a generator for this sequence.

def counterGenerator():
    a, b, c = 5, 5, 3

    yield a 
    yield b 
    yield c

    while True:
        next = a + b - c
        yield next
        a, b, c = b, c, next

counter = counterGenerator()
for i in range(10):
    print(next(counter))
